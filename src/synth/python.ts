// CAIRS Python Synthesizer
// Translates CAIRS documents (AIR/CIR/EIR/LIR) to executable Python code

import type {
	AIRDef, AIRDocument, CIRDocument, EIRDocument,
	Expr, EirExpr, Node, EirNode,
	LIRDocument,
	Value,
} from "../types.js";
import { isExprNode } from "../types.js";

//==============================================================================
// Options and Types
//==============================================================================

export interface PythonSynthOptions {
	/** Module name for generated code (used in comments) */
	moduleName?: string;
	/** Include type hints in generated Python */
	typeHints?: boolean;
	/** Include debug comments */
	debugComments?: boolean;
}

type Document = AIRDocument | CIRDocument | EIRDocument | LIRDocument;

//==============================================================================
// Operator Mappings
//==============================================================================

interface OperatorMapping {
	pythonOp: string;
	customImpl?: (args: string[]) => string;
}

const OPERATOR_MAP: Record<string, OperatorMapping> = {
	"core:add": { pythonOp: "+" },
	"core:sub": { pythonOp: "-" },
	"core:mul": { pythonOp: "*" },
	"core:div": { pythonOp: "//", customImpl: (args) => `int(${args[0]} // ${args[1]})` },
	"core:mod": { pythonOp: "%" },
	"core:pow": { pythonOp: "**" },
	"core:neg": { pythonOp: "-", customImpl: (args) => `(-${args[0]})` },
	"core:eq": { pythonOp: "==" },
	"core:neq": { pythonOp: "!=" },
	"core:lt": { pythonOp: "<" },
	"core:lte": { pythonOp: "<=" },
	"core:gt": { pythonOp: ">" },
	"core:gte": { pythonOp: ">=" },
	"bool:and": { pythonOp: "and" },
	"bool:or": { pythonOp: "or" },
	"bool:not": { pythonOp: "not", customImpl: (args) => `(not ${args[0]})` },
	"list:length": { pythonOp: "len", customImpl: (args) => `len(${args[0]})` },
	"list:concat": { pythonOp: "+", customImpl: (args) => `(${args[0]} + ${args[1]})` },
};

/**
 * Main entry point for Python synthesis
 */
export function synthesizePython(doc: Document, opts: PythonSynthOptions = {}): string {
	const { moduleName = "cairs_generated" } = opts;

	// Detect IR layer and dispatch
	// LIR documents with legacy blocks field get LIR synthesis
	if ("blocks" in doc && doc.blocks && doc.blocks.length > 0) {
		return synthesizeLIR(doc, { moduleName });
	}
	// Expression-based documents (AIR/CIR/EIR) with nodes
	if ("nodes" in doc && "airDefs" in doc) {
		return synthesizeExprBased(doc as AIRDocument | CIRDocument | EIRDocument, { moduleName });
	}

	throw new Error("Unrecognized document format");
}

//==============================================================================
// Expression-Based Synthesis (AIR/CIR/EIR)
//==============================================================================

interface ExprSynthState {
	lines: string[];
	varIndex: number;
	airDefs: Map<string, AIRDef>;
}

function synthesizeExprBased(
	doc: AIRDocument | CIRDocument | EIRDocument,
	opts: PythonSynthOptions,
): string {
	const { moduleName } = opts;
	const state: ExprSynthState = {
		lines: [],
		varIndex: 0,
		airDefs: new Map(),
	};

	// Build AIR def lookup
	for (const airDef of doc.airDefs ?? []) {
		state.airDefs.set(`${airDef.ns}:${airDef.name}`, airDef);
	}

	// Header
	state.lines.push("# Generated by CAIRS Python Synthesizer");
	state.lines.push(`# Module: ${moduleName}`);
	state.lines.push(`# Document version: ${doc.version}`);
	state.lines.push("# IR Layer: expression-based");
	state.lines.push("");

	// Emit AIR defs as Python functions
	if (doc.airDefs && doc.airDefs.length > 0) {
		emitAirDefs(state, doc.airDefs);
		state.lines.push("");
	}

	// Emit node bindings
	state.lines.push("# Node bindings");
	const mutableCells = new Map<string, string>();
	const cellInitLines: string[] = [];

	for (const node of doc.nodes) {
		// Only emit bindings for expr nodes
		if (isExprNode(node)) {
			emitNodeBinding(state, node, mutableCells, cellInitLines);
		}
	}

	// Initialize mutable cells at the start
	if (cellInitLines.length > 0) {
		const insertIndex = state.lines.findIndex((l) => l.startsWith("# Node bindings"));
		if (insertIndex >= 0) {
			state.lines.splice(
				insertIndex,
				0,
				"# Mutable cells",
				...cellInitLines.map((l) => `    ${l}`),
				"",
			);
		}
	}

	state.lines.push("");

	// Emit result
	state.lines.push("# Result");
	state.lines.push(`print(v_${sanitizeId(doc.result)})`);
	state.lines.push("");

	return state.lines.join("\n");
}

function emitNodeBinding(
	state: ExprSynthState,
	node: Node | EirNode,
	mutableCells: Map<string, string>,
	cellInitLines: string[],
): void {
	const varName = `v_${sanitizeId(node.id)}`;

	// Skip already emitted
	if (state.lines.some((l) => l.startsWith(`${varName} =`))) {
		return;
	}

	const exprCode = synthesizeExpr(state, node.expr, mutableCells, cellInitLines);
	state.lines.push(`${varName} = ${exprCode}`);
	state.lines.push("");
}

function synthesizeExpr(
	state: ExprSynthState,
	expr: Expr | EirExpr,
	mutableCells: Map<string, string>,
	cellInitLines: string[],
): string {
	const kind = expr.kind;
	const refToPython = (nodeId: string): string => `v_${sanitizeId(nodeId)}`;

	switch (kind) {
	case "lit": {
		const value = (expr as { value: Value }).value;
		return formatLiteral(value);
	}

	case "ref": {
		const id = (expr as { id: string }).id;
		return refToPython(id);
	}

	case "var": {
		const name = (expr as { name: string }).name;
		return name;
	}

	case "call": {
		const ns = (expr as { ns: string }).ns;
		const opName = (expr as { name: string }).name;
		const args = (expr as { args: string[] }).args;
		const qualName = `${ns}:${opName}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			throw new Error(`Unsupported operator: ${qualName}`);
		}

		const argCodes = args.map(refToPython);

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.pythonOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.pythonOp} ${argCodes[1]})`;
		}

		throw new Error(`Unexpected arity for ${qualName}: ${argCodes.length}`);
	}

	case "if": {
		const condId = (expr as { cond: string }).cond;
		const thenId = (expr as { then: string }).then;
		const elseId = (expr as { else: string }).else;
		return `(${refToPython(thenId)} if ${refToPython(condId)} else ${refToPython(elseId)})`;
	}

	case "let": {
		const name = (expr as { name: string }).name;
		const valueId = (expr as { value: string }).value;
		const bodyId = (expr as { body: string }).body;
		return `(lambda ${name}: ${refToPython(bodyId)})(${refToPython(valueId)})`;
	}

	case "airRef": {
		const ns = (expr as { ns: string }).ns;
		const opName = (expr as { name: string }).name;
		const args = (expr as { args: string[] }).args;
		const qualName = `${ns}:${opName}`;
		const airDef = state.airDefs.get(qualName);

		if (!airDef) {
			throw new Error(`Unknown AIR definition: ${qualName}`);
		}

		const argCodes = args.map(refToPython);
		return `air_${ns}_${opName}(${argCodes.join(", ")})`;
	}

	case "lambda": {
		const params = (expr as { params: string[] }).params;
		const bodyId = (expr as { body: string }).body;
		const paramNames = params.join(", ");
		return `(lambda ${paramNames}: ${refToPython(bodyId)})`;
	}

	case "callExpr": {
		const fnId = (expr as { fn: string }).fn;
		const args = (expr as { args: string[] }).args;
		const argCodes = args.map(refToPython);
		return `${refToPython(fnId)}(${argCodes.join(", ")})`;
	}

	case "fix": {
		const fnId = (expr as { fn: string }).fn;
		const varName = freshVar(state);
		return `(lambda ${varName}: ${refToPython(fnId)}(${varName}))(${varName})`;
	}

	case "predicate": {
		const name = (expr as { name: string }).name;
		return `(lambda ${name}: True)`;
	}

	case "seq": {
		const firstId = (expr as { first: string }).first;
		const thenId = (expr as { then: string }).then;
		return `(lambda _: ${refToPython(thenId)})(${refToPython(firstId)})`;
	}

	case "assign": {
		const target = (expr as { target: string }).target;
		const valueId = (expr as { value: string }).value;
		const value = refToPython(valueId);

		if (!mutableCells.has(target)) {
			const cellName = `_cell_${state.varIndex++}`;
			cellInitLines.push(`${cellName} = {"${target}": ${value}}`);
			mutableCells.set(target, cellName);
		}

		return "None";
	}

	case "while": {
		const condId = (expr as { cond: string }).cond;
		const bodyId = (expr as { body: string }).body;
		return `(lambda _: (${refToPython(bodyId)}, None)[1] if ${refToPython(condId)} else None)(None)`;
	}

	case "iter": {
		const varName = (expr as { var: string }).var;
		const iterId = (expr as { iter: string }).iter;
		const bodyId = (expr as { body: string }).body;
		return `[(lambda ${varName}: ${refToPython(bodyId)})(item) for item in ${refToPython(iterId)}][-1]`;
	}

	case "effect": {
		const op = (expr as { op: string }).op;
		const args = (expr as { args: string[] }).args;
		const argCodes = args.map(refToPython);
		return `print("${op}", ${argCodes.join(", ")})`;
	}

	default: {
		throw new Error(`Unsupported expression kind: ${kind}`);
	}
	}
}

function emitAirDefs(state: ExprSynthState, airDefs: AIRDef[]): void {
	state.lines.push("# AIR definitions");

	for (const airDef of airDefs) {
		const params = airDef.params.join(", ");
		const funcName = `air_${airDef.ns}_${airDef.name}`;
		state.lines.push(`def ${funcName}(${params}):`);
		state.lines.push(`    return ${pythonExpr(airDef.body)}`);
		state.lines.push("");
	}
}

//==============================================================================
// CFG-Based Synthesis (LIR)
//==============================================================================

function synthesizeLIR(doc: LIRDocument, opts: PythonSynthOptions): string {
	const { moduleName } = opts;
	const lines: string[] = [];

	lines.push("# Generated by CAIRS Python Synthesizer");
	lines.push(`# Module: ${moduleName}`);
	lines.push(`# Document version: ${doc.version ?? "1.0.0"}`);
	lines.push("# IR Layer: LIR (CFG-based)");
	lines.push("");
	lines.push("from typing import Dict, Any");
	lines.push("");

	// Emit block definitions
	lines.push("# Blocks");
	lines.push("blocks = {");

	const blocks = doc.blocks ?? [];
	for (const block of blocks) {
		lines.push(`    "${block.id}": {`);
		lines.push(`        "instructions": ${JSON.stringify(block.instructions).replace(/"/g, '\\"')},`);
		lines.push(`        "terminator": ${JSON.stringify(block.terminator).replace(/"/g, '\\"')}`);
		lines.push("    },");
	}

	lines.push("}");
	lines.push("");

	// Emit execution engine
	lines.push("# Execution engine");
	lines.push("def execute_lir(blocks, entry):");
	lines.push("    vars = {}");
	lines.push("    current = entry");
	lines.push("    predecessor = None");
	lines.push("");
	lines.push("    while True:");
	lines.push("        if current not in blocks:");
	lines.push("            raise RuntimeError(f\"Unknown block: {current}\")");
	lines.push("");
	lines.push("        block = blocks[current]");
	lines.push("");
	lines.push("        for inst in block['instructions']:");
	lines.push("            kind = inst['kind']");
	lines.push("");
	lines.push("            if kind == 'assign':");
	lines.push("                vars[inst['target']] = eval_value(inst['value'], vars)");
	lines.push("");
	lines.push("            elif kind == 'op':");
	lines.push("                vars[inst['target']] = apply_operator(inst['ns'], inst['name'], [vars[a] for a in inst['args']])");
	lines.push("");
	lines.push("            elif kind == 'phi':");
	lines.push("                source_id = None");
	lines.push("                for s in inst['sources']:");
	lines.push("                    if s['block'] == predecessor:");
	lines.push("                        source_id = s['id']");
	lines.push("                        break");
	lines.push("                vars[inst['target']] = vars[source_id]");
	lines.push("");
	lines.push("        term = block['terminator']");
	lines.push("");
	lines.push("        if term['kind'] == 'jump':");
	lines.push("            predecessor = current");
	lines.push("            current = term['to']");
	lines.push("");
	lines.push("        elif term['kind'] == 'branch':");
	lines.push("            predecessor = current");
	lines.push("            current = term['then'] if vars[term['cond']] else term['else']");
	lines.push("");
	lines.push("        elif term['kind'] == 'return':");
	lines.push("            return vars.get(term.get('value', ''), None)");
	lines.push("");
	lines.push("        elif term['kind'] == 'exit':");
	lines.push("            return vars.get(term.get('code', ''), 0)");
	lines.push("");
	lines.push("");

	// Helper functions
	lines.push("def eval_value(val, vars):");
	lines.push("    if isinstance(val, dict):");
	lines.push("        kind = val.get('kind')");
	lines.push("        if kind == 'lit':");
	lines.push("            return val['value']");
	lines.push("        elif kind == 'var':");
	lines.push("            return vars[val['name']]");
	lines.push("    return val");
	lines.push("");
	lines.push("def apply_operator(ns, name, args):");
	lines.push("    if ns == 'core' and name == 'add': return args[0] + args[1]");
	lines.push("    if ns == 'core' and name == 'sub': return args[0] - args[1]");
	lines.push("    if ns == 'core' and name == 'mul': return args[0] * args[1]");
	lines.push("    if ns == 'core' and name == 'div': return int(args[0] // args[1])");
	lines.push("    raise RuntimeError(f\"Unknown operator: {ns}:{name}\")");
	lines.push("");
	lines.push("");

	// Main entry
	lines.push("if __name__ == \"__main__\":");
	lines.push(`    result = execute_lir(blocks, "${doc.entry ?? "entry"}")`);
	lines.push("    print(result)");

	return lines.join("\n");
}

//==============================================================================
// Utilities
//==============================================================================

function sanitizeId(id: string): string {
	return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

function freshVar(state: ExprSynthState): string {
	return `_v${state.varIndex++}`;
}

function formatLiteral(value: Value): string {
	if (value === null) return "None";
	if (typeof value === "boolean") return value ? "True" : "False";
	if (typeof value === "string") return JSON.stringify(value);
	if (typeof value === "number") return String(value);
	if (Array.isArray(value)) return `[${value.map(formatLiteral).join(", ")}]`;
	if (typeof value === "object" && value !== null) {
		if (value.kind === "set") {
			const arr = Array.from(value.value);
			return `set([${arr.map((s) => JSON.stringify(s)).join(", ")}])`;
		}
		return "None";
	}
	return String(value);
}

function pythonExpr(expr: Expr | { kind: string; [key: string]: unknown }): string {
	const kind = expr.kind;
	switch (kind) {
	case "ref":
		return `v_${sanitizeId((expr as { id: string }).id)}`;
	case "var":
		return (expr as { name: string }).name;
	case "lit":
		return formatLiteral((expr as { value: Value }).value);
	case "call": {
		const ns = (expr as { ns: string }).ns;
		const opName = (expr as { name: string }).name;
		const args = (expr as { args: (string | Expr)[] }).args;
		const qualName = `${ns}:${opName}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			return "None";
		}

		// Args can be strings (node refs) or inline Expr objects (in AIR defs)
		const argCodes = args.map((arg) => {
			if (typeof arg === "string") {
				return `v_${sanitizeId(arg)}`;
			}
			return pythonExpr(arg);
		});

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.pythonOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.pythonOp} ${argCodes[1]})`;
		}

		return "None";
	}
	default:
		return "None";
	}
}
