{
  "description": "Fibonacci using the fix combinator for recursion. The fix combinator enables self-reference by computing the least fixed point of a function. fix F = F (fix F), allowing the function F to receive itself as its first parameter, enabling recursion. Fibonacci: fib(n) = if n <= 1 then n else fib(n-1) + fib(n-2).",
  "formula": "fix fib_rec where fib_rec = lambda rec. lambda n. if n <= 1 then n else rec(n-1) + rec(n-2)",
  "example": "fibonacci(7) = 13",
  "version": "1.0.0",
  "airDefs": [
    {
      "ns": "core",
      "name": "lte",
      "params": ["a", "b"],
      "result": { "kind": "bool" },
      "body": { "kind": "ref", "id": "a" }
    },
    {
      "ns": "core",
      "name": "sub",
      "params": ["a", "b"],
      "result": { "kind": "int" },
      "body": { "kind": "ref", "id": "a" }
    },
    {
      "ns": "core",
      "name": "add",
      "params": ["a", "b"],
      "result": { "kind": "int" },
      "body": { "kind": "ref", "id": "a" }
    }
  ],
  "nodes": [
    {
      "id": "zero",
      "expr": {
        "kind": "lit",
        "type": { "kind": "int" },
        "value": 0
      }
    },
    {
      "id": "one",
      "expr": {
        "kind": "lit",
        "type": { "kind": "int" },
        "value": 1
      }
    },
    {
      "id": "two",
      "expr": {
        "kind": "lit",
        "type": { "kind": "int" },
        "value": 2
      }
    },
    {
      "id": "seven",
      "expr": {
        "kind": "lit",
        "type": { "kind": "int" },
        "value": 7
      }
    },
    {
      "id": "thirteen",
      "expr": {
        "kind": "lit",
        "type": { "kind": "int" },
        "value": 13
      }
    },
    {
      "id": "fibRec",
      "expr": {
        "kind": "lambda",
        "params": ["rec"],
        "body": "fibInner",
        "type": {
          "kind": "fn",
          "params": [{ "kind": "fn", "params": [{ "kind": "int" }], "returns": { "kind": "int" } }],
          "returns": { "kind": "fn", "params": [{ "kind": "int" }], "returns": { "kind": "int" } }
        }
      }
    },
    {
      "id": "fibInner",
      "expr": {
        "kind": "lambda",
        "params": ["n"],
        "body": "fibBody",
        "type": {
          "kind": "fn",
          "params": [{ "kind": "int" }],
          "returns": { "kind": "int" }
        }
      }
    },
    {
      "id": "fibBody",
      "expr": {
        "kind": "let",
        "name": "isLeOne",
        "value": "checkLeOne",
        "body": "branchResult"
      }
    },
    {
      "id": "checkLeOne",
      "expr": {
        "kind": "call",
        "ns": "core",
        "name": "lte",
        "args": ["n", "one"]
      }
    },
    {
      "id": "branchResult",
      "expr": {
        "kind": "if",
        "cond": "isLeOne",
        "then": "n",
        "else": "recursiveCase",
        "type": { "kind": "int" }
      }
    },
    {
      "id": "recursiveCase",
      "expr": {
        "kind": "let",
        "name": "nMinusOne",
        "value": "decrementOne",
        "body": "computeFibMinusOne"
      }
    },
    {
      "id": "decrementOne",
      "expr": {
        "kind": "call",
        "ns": "core",
        "name": "sub",
        "args": ["n", "one"]
      }
    },
    {
      "id": "computeFibMinusOne",
      "expr": {
        "kind": "let",
        "name": "fibNMinusOne",
        "value": "recCallOne",
        "body": "computeFibMinusTwo"
      }
    },
    {
      "id": "recCallOne",
      "expr": {
        "kind": "callExpr",
        "fn": "rec",
        "args": ["nMinusOne"]
      }
    },
    {
      "id": "computeFibMinusTwo",
      "expr": {
        "kind": "let",
        "name": "nMinusTwo",
        "value": "decrementTwo",
        "body": "computeFibMinusTwoVal"
      }
    },
    {
      "id": "decrementTwo",
      "expr": {
        "kind": "call",
        "ns": "core",
        "name": "sub",
        "args": ["n", "two"]
      }
    },
    {
      "id": "computeFibMinusTwoVal",
      "expr": {
        "kind": "let",
        "name": "fibNMinusTwo",
        "value": "recCallTwo",
        "body": "sumResult"
      }
    },
    {
      "id": "recCallTwo",
      "expr": {
        "kind": "callExpr",
        "fn": "rec",
        "args": ["nMinusTwo"]
      }
    },
    {
      "id": "sumResult",
      "expr": {
        "kind": "call",
        "ns": "core",
        "name": "add",
        "args": ["fibNMinusOne", "fibNMinusTwo"]
      }
    },
    {
      "id": "fibFixed",
      "expr": {
        "kind": "fix",
        "fn": "fibRec",
        "type": {
          "kind": "fn",
          "params": [{ "kind": "int" }],
          "returns": { "kind": "int" }
        }
      }
    },
    {
      "id": "result",
      "expr": {
        "kind": "callExpr",
        "fn": "fibFixed",
        "args": ["seven"]
      }
    }
  ],
  "result": "result",
  "expected_result": 13,
  "computation_trace": [
    { "step": 1, "description": "fix fibRec binds fibRec to its own application" },
    { "step": 2, "description": "fibFixed = fibRec(fibFixed)" },
    { "step": 3, "description": "Call fibFixed(7)" },
    { "step": 4, "n": 7, "check": "7 <= 1", "result": false, "action": "compute fib(6) + fib(5)" },
    { "step": 5, "n": 6, "check": "6 <= 1", "result": false, "action": "compute fib(5) + fib(4)" },
    { "step": 6, "n": 5, "check": "5 <= 1", "result": false, "action": "compute fib(4) + fib(3)" },
    { "step": 7, "n": 4, "check": "4 <= 1", "result": false, "action": "compute fib(3) + fib(2)" },
    { "step": 8, "n": 3, "check": "3 <= 1", "result": false, "action": "compute fib(2) + fib(1)" },
    { "step": 9, "n": 2, "check": "2 <= 1", "result": false, "action": "compute fib(1) + fib(0)" },
    { "step": 10, "n": 1, "check": "1 <= 1", "result": true, "returns": 1 },
    { "step": 11, "n": 0, "check": "0 <= 1", "result": true, "returns": 0 },
    { "step": 12, "description": "fib(2) = fib(1) + fib(0) = 1 + 0 = 1" },
    { "step": 13, "description": "fib(3) = fib(2) + fib(1) = 1 + 1 = 2" },
    { "step": 14, "description": "fib(4) = fib(3) + fib(2) = 2 + 1 = 3" },
    { "step": 15, "description": "fib(5) = fib(4) + fib(3) = 3 + 2 = 5" },
    { "step": 16, "description": "fib(6) = fib(5) + fib(4) = 5 + 3 = 8" },
    { "step": 17, "description": "fib(7) = fib(6) + fib(5) = 8 + 5 = 13" }
  ],
  "notes": [
    "The fix combinator solves the self-reference problem in lambda calculus",
    "fix F expands to F(fix F), giving F access to itself via its first parameter",
    "Fibonacci is the classic example of tree recursion - each call spawns two more calls",
    "Type of fix: (T -> T) -> T for any type T",
    "Here T = int -> int, so fix has type ((int -> int) -> (int -> int)) -> (int -> int)",
    "The fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ..."
  ]
}
